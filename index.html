<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AI Unified Tool v2.0.0 — Neon GUI (Single File)</title>

<style>
/* ================== FULL CSS RESET + ADAPTER ================== */

/* Reset default browser styles */
html, body, div, span, applet, object, iframe,
h1,h2,h3,h4,h5,h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
  margin: 0; padding: 0; border: 0; font: inherit; vertical-align: baseline;
}

/* HTML5 display fixes */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section { display: block; }

body {
  line-height: 1; min-height:100vh; overflow-x:hidden;
  background: #1a0a0f; /* fallback for gradient */
  font-family: 'SF Mono','Monaco','Inconsolata','Roboto Mono', monospace;
}

ol, ul { list-style: none; }

a { text-decoration: none; color: inherit; }

table { border-collapse: collapse; border-spacing: 0; }

button, input, select, textarea {
  font-family: inherit; font-size: inherit;
  background: none; border: none; outline: none; color: inherit;
  -webkit-tap-highlight-color: transparent;
}

img, video, canvas { display: block; max-width:100%; height:auto; }

* { box-sizing: border-box; }

/* ================== GLOBAL THEME OVERRIDES ================== */
:root {
  --color-neon-yellow: #ffff33;
  --color-neon-green: #00ff00;
  --color-neon-blue: #00ccff;
  --color-neon-red: #ff3300;
  --color-paragraph: #ffffff;
  --color-background-gradient: linear-gradient(135deg, #1a0a0f, #0a1a2f, #2f0a1a);
  --font-glow: 0 0 6px var(--color-neon-yellow), 0 0 10px var(--color-neon-yellow);
}

/* Body background & default */
body {
  background: var(--color-background-gradient);
  color: var(--color-paragraph);
}

/* Headings glow */
h1,h2,h3,h4,h5,h6 { color: var(--color-neon-yellow); text-shadow: var(--font-glow); }

/* Paragraphs */
p { color: var(--color-paragraph); line-height:1.5; text-shadow:0 0 3px #ffffff33; }

/* Lists */
ul li, ol li { color: var(--color-neon-yellow); text-shadow:0 0 4px #ffff33; }

/* Links */
a { color: var(--color-neon-blue); text-shadow:0 0 6px #00ccff; }

/* Buttons */
button { cursor:pointer; border-radius:6px; background: rgba(0,255,204,0.1); padding:8px 12px; color:#00ffcc; box-shadow:0 0 6px #00ffcc; transition: all 0.2s ease; }
button:hover { background: rgba(0,255,204,0.3); box-shadow:0 0 12px #00ffcc; }
button:disabled { cursor: not-allowed; opacity: 0.5; }

/* Forms */
input, textarea, select { background: rgba(0,0,0,0.3); border:1px solid #00ffcc; padding:6px 10px; color:#00ffcc; border-radius:4px; outline:none; transition:0.2s; }
input:focus, textarea:focus, select:focus { border-color:#ffff33; box-shadow:0 0 8px #ffff33; }

/* Canvas full viewport adapter */
canvas.fullscreen-adapter {
  position: absolute;
  top:0; left:0;
  width:100%; height:100%;
  pointer-events:none;
  z-index:0;
}

/* Overlay / panels */
.panel, .alert-panel {
  position:relative; border-radius:12px; padding:12px; background:rgba(0,0,0,0.7);
  border:2px solid #00ffcc; color:#00ffcc; text-shadow:0 0 5px #00ffcc;
  pointer-events:auto; z-index:2;
}

/* Parallax layers adapter */
.parallax-layer {
  position:absolute; top:0; left:0;
  width:100%; height:100%;
  pointer-events:none;
  transform-style: preserve-3d;
}

/* Smooth scrolling and transitions */
* { scroll-behavior: smooth; transition: all 0.2s ease-in-out; }

/* ================== LAYOUT ================== */
.wrapper { position:relative; width:100%; min-height:100vh; overflow:hidden; }
.content { position:relative; z-index:2; padding:24px; }
.grid { display:grid; grid-template-columns: 1.4fr .6fr; gap:16px; }
@media (max-width: 1100px){ .grid { grid-template-columns:1fr; } }
.row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
.stack { display:flex; flex-direction:column; gap:10px; }
.card { padding:14px; border-radius:14px; border:2px solid #00ffcc55; background:rgba(10,20,20,0.35); box-shadow:0 0 24px rgba(0,255,204,.15) inset; }
.card h3 { margin-bottom:8px; }
.small { font-size:12px; opacity:.85; }
.mono { font-family: 'SF Mono','Monaco','Inconsolata','Roboto Mono', monospace; }
.tag { border:1px solid #00ccff; padding:2px 8px; border-radius:999px; font-size:12px; color:#00ccff; }
hr.sep { border:0; border-top:1px dashed #00ffcc55; margin:10px 0; }
.footer-note { font-size:12px; opacity:.7; }

/* Console */
.console { background:rgba(0,0,0,0.6); border:2px solid #00ffcc; border-radius:12px; padding:10px; height:320px; overflow:auto; }
.console .line { white-space:pre-wrap; }
.console .muted { color:#9ae6ffcc; }
.console .ok { color:#66ff99; text-shadow:0 0 6px #66ff99; }
.console .warn { color:#ffd166; text-shadow:0 0 6px #ffd166; }
.console .err { color:#ff6b6b; text-shadow:0 0 6px #ff6b6b; }

/* Buttons row */
.actions button { min-width:120px; }

/* Chat pane */
.chat-log { height:220px; overflow:auto; background:rgba(0,0,0,.5); border:1px solid #00ffcc55; border-radius:8px; padding:10px; }
.chat-msg { margin-bottom:6px; }
.chat-msg.me { color:#00ccff; }
.chat-msg.ai { color:#66ff99; }

/* Tabs */
.tabs { display:flex; gap:8px; margin:8px 0; }
.tab-btn { padding:6px 10px; border:1px solid #00ffcc55; border-radius:8px; }
.tab-btn.active { border-color:#ffff33; color:#ffff33; box-shadow:0 0 12px #ffff33; }
.tab-panel { display:none; }
.tab-panel.active { display:block; }

/* Header */
header { display:flex; align-items:center; justify-content:space-between; margin-bottom:14px; flex-wrap:wrap; }
.brand { display:flex; align-items:center; gap:10px; }
.logo { width:34px; height:34px; border-radius:10px; background: radial-gradient(circle at 30% 30%, #00ffcc, #001111 60%); box-shadow:0 0 20px #00ffcc; }
h1.title { letter-spacing:.5px; }

/* Badges */
.badges { display:flex; gap:8px; flex-wrap:wrap; }
.badges .tag { background:rgba(0,0,0,.35); }

/* Inputs sizing */
input[type="number"]{ width:90px; }
input[type="text"]{ min-width:240px; }
textarea{ min-height:100px; }
.swap-interface select { flex-grow: 1; }
</style>
</head>
<body>
<div class="wrapper" id="appRoot"></div>

<div class="content">
  <header>
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1 class="title">AI Unified Tool v2.0.0 — Neon GUI</h1>
        <div class="small">Rebased from Bash to browser — single-file, CORS-permitting Ollama integration</div>
      </div>
    </div>
    <div class="badges">
      <span class="tag">Single-file</span>
      <span class="tag">No build</span>
      <span class="tag">LocalStorage config</span>
    </div>
  </header>

  <section class="grid">
    <!-- LEFT: Main controls -->
    <div class="stack">
      <div class="card panel">
        <h3>AI Processing</h3>
        <div class="row">
          <input id="promptInput" type="text" placeholder="Type a prompt…">
          <button id="runBtn">Run</button>
          <button id="helpBtn">Help</button>
        </div>
        <div class="row">
          <input id="ollamaEndpoint" type="text" placeholder="http://localhost:11434/api/generate">
          <input id="modelInput" type="text" placeholder="Model" value="gemma3:1b">
          <label class="small">Temp <input id="tempInput" type="number" step="0.1" min="0.1" max="2.0" value="0.7"></label>
          <label class="small">Max Tokens <input id="maxTokensInput" type="number" min="1" max="10000" value="1000"></label>
          <label class="small">Timeout (s) <input id="timeoutInput" type="number" min="1" max="300" value="30"></label>
        </div>
        <div class="actions row">
          <button id="saveCfgBtn">Save Config</button>
          <button id="listModelsBtn">List Models</button>
          <button id="switchModelBtn">Switch Model</button>
          <button id="clearConsoleBtn">Clear Console</button>
        </div>
      </div>

      <div class="card panel">
        <h3>Interactive Chat</h3>
        <div class="chat-log mono" id="chatLog" aria-live="polite"></div>
        <div class="row" style="margin-top:8px">
          <input id="chatInput" type="text" placeholder="You: message…">
          <button id="sendChatBtn">Send</button>
          <button id="resetChatBtn">Reset</button>
        </div>
      </div>

      <div class="card panel">
        <h3>Console & Logs</h3>
        <div class="console mono" id="console"></div>
        <div class="row" style="margin-top:8px">
          <button id="exportLogsBtn">Export Logs</button>
          <button id="purgeLogsBtn">Purge Logs</button>
        </div>
      </div>
    </div>

    <!-- RIGHT: Modules -->
    <div class="stack">
      <div class="card panel">
        <h3>BITBOY AI-DEX</h3>
        <div class="tabs" id="dexTabs">
          <button class="tab-btn active" data-tab="dexWalletTab">Wallet</button>
          <button class="tab-btn" data-tab="dexSwapTab">Swap</button>
          <button class="tab-btn" data-tab="dexAiTab">AI Analyst</button>
        </div>
        <div id="dexWalletTab" class="tab-panel active">
          <div class="stack">
            <button id="connectWalletBtn">Connect Wallet</button>
            <div id="walletInfo" style="display:none; margin-top:8px;">
              <p class="small mono">Address: <span id="walletAddress"></span></p>
              <p class="small mono">Balance: <span id="walletBalance"></span></p>
            </div>
          </div>
        </div>
        <div id="dexSwapTab" class="tab-panel">
          <div class="stack swap-interface">
              <label>From</label>
              <div class="row">
                  <input id="swapFromAmount" type="number" value="1">
                  <select id="swapFromToken">
                      <option>ETH</option>
                      <option>BTC</option>
                      <option>BITBOY</option>
                  </select>
              </div>
              <label>To (estimated)</label>
              <div class="row">
                  <input id="swapToAmount" type="number" readonly>
                  <select id="swapToToken">
                      <option>USDT</option>
                      <option>ETH</option>
                  </select>
              </div>
              <p class="small" id="swapRate"></p>
              <button id="swapBtn">Swap</button>
          </div>
        </div>
        <div id="dexAiTab" class="tab-panel">
          <div class="stack">
              <button id="aiSignalBtn">Get AI Trade Signal</button>
              <pre class="mono" id="aiSignalOutput" style="margin-top:8px; white-space:pre-wrap;"></pre>
          </div>
        </div>
      </div>

      <div class="card panel">
        <h3>Cryptographic Operations</h3>
        <div class="tabs">
          <button class="tab-btn active" data-tab="handshakeTab">Handshake</button>
          <button class="tab-btn" data-tab="entropyTab">Entropy</button>
        </div>
        <div id="handshakeTab" class="tab-panel active">
          <div class="stack">
            <input id="hsMessage" type="text" placeholder="Handshake message">
            <input id="hsId" type="text" placeholder="Optional handshake id">
            <button id="hsRunBtn">Run Handshake</button>
          </div>
        </div>
        <div id="entropyTab" class="tab-panel">
          <div class="row">
            <label class="small">Length (1-1024)</label>
            <input id="entropyLen" type="number" min="1" max="1024" value="64">
            <button id="entropyBtn">Generate</button>
          </div>
          <textarea id="entropyOut" readonly></textarea>
        </div>
      </div>

      <div class="card panel">
        <h3>System & Tuning</h3>
        <div class="tabs">
          <button class="tab-btn active" data-tab="sysTab">System</button>
          <button class="tab-btn" data-tab="tuningTab">Tuning</button>
        </div>
        <div id="sysTab" class="tab-panel active">
          <div class="stack">
            <button id="sysStatusBtn">Show System Status</button>
            <pre class="mono" id="sysReport"></pre>
          </div>
        </div>
        <div id="tuningTab" class="tab-panel">
          <div class="stack">
            <div class="small">Temperature controls creativity:
              <ul>
                <li>0.1–0.5: More deterministic</li>
                <li>0.5–0.8: Balanced</li>
                <li>0.8–1.2: More creative</li>
              </ul>
            </div>
            <div class="row">
              <label>Temperature</label><input id="tunTemp" type="number" step="0.1" min="0.1" max="2.0" value="0.7">
              <label>Max Tokens</label><input id="tunMaxTok" type="number" min="1" max="10000" value="1000">
              <label>Timeout (s)</label><input id="tunTimeout" type="number" min="1" max="300" value="30">
              <button id="tunApplyBtn">Apply</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card panel">
        <h3>Help</h3>
        <details>
          <summary>General</summary>
          <pre class="mono" id="helpGeneral"></pre>
        </details>
        <details>
          <summary>Crypto</summary>
          <pre class="mono" id="helpCrypto"></pre>
        </details>
        <details>
          <summary>System</summary>
          <pre class="mono" id="helpSystem"></pre>
        </details>
        <details>
          <summary>Model</summary>
          <pre class="mono" id="helpModel"></pre>
        </details>
        <details>
          <summary>Tuning</summary>
          <pre class="mono" id="helpTuning"></pre>
        </details>
      </div>
    </div>
  </section>

  <p class="footer-note" style="margin-top:14px">
    Ollama calls require CORS permission from your server (e.g., running on localhost). When unreachable, this app automatically falls back to simulated responses.
  </p>
</div>

<script>
// ================== DOM ADAPTER ==================
function setupDOMAdapter(container){
  container.style.position = 'relative';
  container.style.width = '100%';
  container.style.minHeight = '100vh';
  container.style.overflow = 'hidden';
  const layers = [];
  for(let i=0;i<20;i++){
    const layer = document.createElement('div');
    layer.className = 'parallax-layer';
    layer.style.zIndex = i;
    layer.style.background = i % 5 === 0 ? 'radial-gradient(600px 600px at '+(i*5)+'% '+(i*2)+'%, rgba(0,255,204,.06), transparent 70%)' : '';
    container.appendChild(layer);
    layers.push(layer);
  }
  return layers;
}
const parallaxLayers = setupDOMAdapter(document.getElementById('appRoot'));

// ================== UTIL & LOGGING ==================
const $ = (s)=>document.querySelector(s);
const consoleEl = $("#console");
function ts(){ return new Date().toISOString().replace('T',' ').replace('Z',''); }
function log(level, msg, cls){
  const line = document.createElement('div');
  line.className = 'line ' + (cls||'');
  line.textContent = `[${ts()}] [${level}] ${msg}`;
  consoleEl.appendChild(line);
  consoleEl.scrollTop = consoleEl.scrollHeight;
  persistLog(line.textContent);
}
function logInfo(m){ log('INFO', m, 'muted'); }
function logOk(m){ log('OK', m, 'ok'); }
function logWarn(m){ log('WARN', m, 'warn'); }
function logErr(m){ log('ERROR', m, 'err'); }

// localStorage logs
const LOG_KEY = 'ai.logs.v2';
function persistLog(text){
  const arr = JSON.parse(localStorage.getItem(LOG_KEY) || '[]');
  arr.push(text);
  // cap to 2000 lines
  if(arr.length > 2000) arr.splice(0, arr.length-2000);
  localStorage.setItem(LOG_KEY, JSON.stringify(arr));
}
function loadLogs(){
  const arr = JSON.parse(localStorage.getItem(LOG_KEY) || '[]');
  arr.forEach(l=>{
    const d=document.createElement('div'); d.className='line'; d.textContent=l;
    consoleEl.appendChild(d);
  });
}

// ================== CONFIG ==================
const CFG_KEY = 'ai.config.v2';
const defaultCfg = {
  model: 'gemma3:1b',
  temperature: 0.7,
  maxTokens: 1000,
  timeout: 30,
  endpoint: '' // e.g. http://localhost:11434/api/generate
};
function getCfg(){
  return Object.assign({}, defaultCfg, JSON.parse(localStorage.getItem(CFG_KEY) || '{}'));
}
function saveCfg(cfg){
  localStorage.setItem(CFG_KEY, JSON.stringify(cfg));
  logOk('Configuration saved.');
}
function loadCfgToUI(){
  const cfg = getCfg();
  $("#modelInput").value = cfg.model;
  $("#tempInput").value = cfg.temperature;
  $("#maxTokensInput").value = cfg.maxTokens;
  $("#timeoutInput").value = cfg.timeout;
  $("#ollamaEndpoint").value = cfg.endpoint;
  $("#tunTemp").value = cfg.temperature;
  $("#tunMaxTok").value = cfg.maxTokens;
  $("#tunTimeout").value = cfg.timeout;
}

// ================== OLLAMA CALLS (with fallback) ==================
async function withTimeout(promise, ms){
  const ctl = new AbortController();
  const t = setTimeout(()=>ctl.abort(), ms);
  try{
    const res = await promise(ctl.signal);
    return res;
  }finally{ clearTimeout(t); }
}
async function aiProcess(prompt){
  const cfg = getCfg();
  logInfo(`Processing prompt: ${prompt.slice(0,100)}…`);

  if(!cfg.endpoint){
    logWarn('No Ollama endpoint set — using simulated response.');
    return `Ollama not available. Simulated response to: ${prompt}`;
  }

  try{
    const payload = { model: cfg.model, prompt, stream:false, options: { temperature: Number(cfg.temperature)||0.7, num_predict: Number(cfg.maxTokens)||1000 } };
    const res = await withTimeout(async (signal)=>{
      return fetch(cfg.endpoint, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload), signal });
    }, (Number(cfg.timeout)||30)*1000);

    if(!res.ok){
      logWarn(`Ollama responded ${res.status}. Falling back.`);
      return `Ollama error (${res.status}). Simulated response to: ${prompt}`;
    }
    const data = await res.json();
    const out = data.response || data.output || '';
    logOk('AI response generated.');
    return out || '[[Empty response]]';
  }catch(e){
    logWarn('Ollama not reachable or CORS blocked — using simulated response.');
    return `Ollama not available. Simulated response to: ${prompt}`;
  }
}
async function ollamaTags(){
  const cfg = getCfg();
  if(!cfg.endpoint){
    logWarn('No endpoint set for listing models.');
    return { ok:false, models:[] };
  }
  try{
    const base = cfg.endpoint.replace(/\/api\/generate.*$/,''); // crude base
    const url = base + '/api/tags';
    const res = await fetch(url, { method:'GET' });
    if(!res.ok) throw new Error('bad status');
    const data = await res.json();
    const models = (data.models || data || []).map(m=>m.name || m.model || String(m));
    logOk(`Fetched ${models.length} model(s) from Ollama.`);
    return { ok:true, models };
  }catch(e){
    logWarn('Failed to fetch models (CORS or server).');
    return { ok:false, models:[] };
  }
}

// ================== CHAT ==================
const chatLog = $("#chatLog");
function addChat(role, text){
  const div = document.createElement('div');
  div.className = 'chat-msg ' + (role==='me'?'me':'ai');
  div.textContent = (role==='me'?'You: ':'AI: ') + text;
  chatLog.appendChild(div);
  chatLog.scrollTop = chatLog.scrollHeight;
}
async function sendChat(msg){
  if(!msg.trim()) return;
  addChat('me', msg);
  $('#chatInput').value = '';
  const reply = await aiProcess(msg);
  addChat('ai', reply);
}

// ================== CRYPTO ==================
async function sha256Hex(str){
  const enc = new TextEncoder().encode(str);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  const view = new Uint8Array(buf);
  return [...view].map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function cryptoHandshake(message, handshakeId){
  if(!message){ logErr('No message provided for handshake'); return "Usage: crypto handshake <message> [id]"; }
  const id = handshakeId || ('handshake_'+Math.floor(Date.now()/1000));
  const timestamp = Math.floor(Date.now()/1000);
  const hash = await sha256Hex(`${message}${timestamp}${id}`);
  logOk(`Handshake completed: ${id}`);
  return `Handshake ID: ${id}\nTimestamp: ${timestamp}\nMessage: ${message}\nSHA256 Hash: ${hash}\nComplete: ✓`;
}
function cryptoEntropy(length){
  const n = Number(length)||64;
  if(n<1 || n>1024){ logErr(`Invalid length: ${n}. Must be between 1-1024`); return ""; }
  const bytes = new Uint8Array(Math.ceil(n/2));
  crypto.getRandomValues(bytes);
  const hex = [...bytes].map(b=>b.toString(16).padStart(2,'0')).join('').slice(0,n);
  logOk(`Entropy generation completed (${n} hex chars).`);
  return hex;
}

// ================== SYSTEM STATUS ==================
async function systemStatus(){
  const cfg = getCfg();
  const nav = navigator;
  const mem = performance && performance.memory ? performance.memory : null;
  let ollamaStatus = '✗ Not checked';
  if(cfg.endpoint){
    try{
      const base = cfg.endpoint.replace(/\/api\/generate.*$/,'');
      const v = await fetch(base + '/api/version', { method:'GET' });
      if(v.ok) ollamaStatus = '✓ Reachable'; else ollamaStatus = '✗ Unreachable';
    }catch{ ollamaStatus = '✗ Unreachable'; }
  }else{
    ollamaStatus = '✗ Not configured';
  }
  const report = [
    "=== SYSTEM STATUS REPORT (Browser) ===",
    "Generated: " + new Date().toString(),
    "",
    "Navigator: " + (nav.userAgent || 'unknown'),
    "Platform: " + (nav.platform || 'unknown'),
    "Cores: " + (nav.hardwareConcurrency || 'unknown'),
    "Online: " + (nav.onLine ? 'Yes' : 'No'),
    "Memory (approx): " + (mem ? `${(mem.usedJSHeapSize/1e6).toFixed(1)}MB / ${(mem.jsHeapSizeLimit/1e6).toFixed(0)}MB` : "n/a"),
    "",
    "AI Configuration:",
    `  Model: ${cfg.model}`,
    `  Temperature: ${cfg.temperature}`,
    `  Max Tokens: ${cfg.maxTokens}`,
    `  Timeout: ${cfg.timeout}s`,
    "",
    `Ollama: ${ollamaStatus}`
  ].join("\n");
  logInfo('System status generated.');
  return report;
}

// ================== HELP TEXTS (ported) ==================
const HELP_GENERAL = `AI Unified Tool v2.0.0

Usage: Use the GUI panels to run operations. This app mirrors the Bash tool's commands in a user-friendly interface. Configure your Ollama endpoint and model, then type prompts or use the specialized modules.

- Main prompt: For general text generation.
- Chat: For conversational AI.
- Modules: For specific tasks like crypto and system analysis.
- Config is saved to your browser's LocalStorage.
`;
const HELP_CRYPTO = `Cryptographic Operations

- Handshake: Simulates a cryptographic handshake. Provide a message and an optional ID. It generates a timestamp and a SHA-256 hash of the combined data, useful for verifying data integrity or as a simple proof-of-work.

- Entropy: Generates a cryptographically secure random hexadecimal string of a specified length (1-1024). Useful for creating keys, salts, or any data requiring high-quality randomness.
`;
const HELP_SYSTEM = `System & Tuning

- System Status: Displays a report of your browser environment, AI configuration, and the status of the Ollama connection.

- Tuning: Allows you to adjust AI model parameters like temperature (creativity), max tokens (response length), and timeout. Changes made here apply to all AI operations.
`;
const HELP_MODEL = `Model Management

- List Models: Fetches and displays available models from your Ollama instance.
- Switch Model: Allows you to change the active model by typing its name in the model input field.
- The default model is 'gemma3:1b'. Ensure any model you use is available on your Ollama server.
`;
const HELP_TUNING = `Tuning Parameters

- Temperature: Controls randomness. Lower values (e.g., 0.2) make the output more deterministic and focused. Higher values (e.g., 1.0) make it more creative and diverse.

- Max Tokens: The maximum number of tokens (words/pieces of words) the model can generate in a single response.

- Timeout: The maximum time in seconds to wait for a response from the Ollama server before giving up.
`;

// ================== UI BINDINGS ==================
function setupUI(){
  loadCfgToUI();
  loadLogs();
  logInfo('AI Unified Tool v2.0.0 initialized.');

  // Generic tab handler
  document.body.addEventListener('click', e => {
    const button = e.target.closest('.tab-btn');
    if (!button) return;

    const tabsContainer = button.closest('.tabs');
    if (!tabsContainer) return;

    const parent = tabsContainer.closest('.card');
    if (!parent) return;

    const tabId = button.dataset.tab;

    tabsContainer.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    button.classList.add('active');

    parent.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
    const activePanel = parent.querySelector('#' + tabId);
    if(activePanel) activePanel.classList.add('active');
  });

  // Main controls
  $('#runBtn').addEventListener('click', async ()=>{
    const p = $('#promptInput').value;
    if(!p) return logWarn('Prompt is empty.');
    const res = await aiProcess(p);
    logInfo('Response:\n' + res);
  });
  $('#helpBtn').addEventListener('click', ()=>logInfo(HELP_GENERAL));
  $('#saveCfgBtn').addEventListener('click', ()=>{
    saveCfg({
      model: $("#modelInput").value,
      temperature: Number($("#tempInput").value),
      maxTokens: Number($("#maxTokensInput").value),
      timeout: Number($("#timeoutInput").value),
      endpoint: $("#ollamaEndpoint").value,
    });
  });
  $('#listModelsBtn').addEventListener('click', async ()=>{
    const {ok, models} = await ollamaTags();
    if(ok) logInfo('Available models:\n' + models.join('\n'));
    else logErr('Could not retrieve models.');
  });
  $('#switchModelBtn').addEventListener('click', ()=>logInfo(`Model set to: ${$('#modelInput').value}. Save config to persist.`));
  $('#clearConsoleBtn').addEventListener('click', ()=>{ consoleEl.innerHTML = ''; });

  // Chat
  $('#sendChatBtn').addEventListener('click', ()=>sendChat($('#chatInput').value));
  $('#chatInput').addEventListener('keydown', (e)=>{ if(e.key==='Enter') sendChat($('#chatInput').value); });
  $('#resetChatBtn').addEventListener('click', ()=>{ chatLog.innerHTML=''; logInfo('Chat history cleared.'); });
  
  // Console
  $('#exportLogsBtn').addEventListener('click', ()=>{
      const logs = JSON.parse(localStorage.getItem(LOG_KEY) || '[]').join('\n');
      const blob = new Blob([logs], {type:'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `ai-tool-logs-${Date.now()}.txt`;
      a.click();
      logOk('Logs exported.');
  });
  $('#purgeLogsBtn').addEventListener('click', ()=>{
      localStorage.removeItem(LOG_KEY);
      consoleEl.innerHTML = '';
      logWarn('All logs purged.');
  });

  // Crypto
  $('#hsRunBtn').addEventListener('click', async ()=>{
      const res = await cryptoHandshake($('#hsMessage').value, $('#hsId').value);
      logInfo('Handshake Result:\n' + res);
  });
  $('#entropyBtn').addEventListener('click', ()=>{
      $('#entropyOut').value = cryptoEntropy($('#entropyLen').value);
  });

  // System
  $('#sysStatusBtn').addEventListener('click', async ()=>{
      $('#sysReport').textContent = await systemStatus();
  });
  $('#tunApplyBtn').addEventListener('click', ()=>{
      $("#tempInput").value = $("#tunTemp").value;
      $("#maxTokensInput").value = $("#tunMaxTok").value;
      $("#timeoutInput").value = $("#tunTimeout").value;
      logOk('Tuning parameters applied. Save config to persist.');
  });

  // Help details
  $('#helpGeneral').textContent = HELP_GENERAL;
  $('#helpCrypto').textContent = HELP_CRYPTO;
  $('#helpSystem').textContent = HELP_SYSTEM;
  $('#helpModel').textContent = HELP_MODEL;
  $('#helpTuning').textContent = HELP_TUNING;

  // BITBOY AI-DEX Module
  $('#connectWalletBtn').addEventListener('click', () => {
    logInfo('Simulating wallet connection...');
    const walletAddress = '0x' + [...crypto.getRandomValues(new Uint8Array(20))].map(b => b.toString(16).padStart(2, '0')).join('');
    const walletBalance = (Math.random() * 5 + 0.1).toFixed(4) + ' ETH';
    $('#walletAddress').textContent = walletAddress;
    $('#walletBalance').textContent = walletBalance;
    $('#walletInfo').style.display = 'block';
    $('#connectWalletBtn').textContent = 'Wallet Connected';
    $('#connectWalletBtn').disabled = true;
    logOk('Wallet connected (simulated).');
  });
  
  const exchangeRates = {
    'ETH': { 'USDT': 3000.52, 'ETH': 1 },
    'BTC': { 'USDT': 60123.45, 'ETH': 20.04 },
    'BITBOY': { 'USDT': 0.11, 'ETH': 0.000033 },
    'USDT': { 'ETH': 1/3000.52, 'USDT': 1 }
  };

  function updateSwap() {
    const fromToken = $('#swapFromToken').value;
    const toToken = $('#swapToToken').value;
    const fromAmount = parseFloat($('#swapFromAmount').value) || 0;
    
    if (fromToken === toToken) {
      $('#swapToAmount').value = fromAmount.toFixed(6);
      $('#swapRate').textContent = '1:1 Ratio';
      return;
    }
    const rate = exchangeRates[fromToken]?.[toToken];
    if (!rate) {
      $('#swapToAmount').value = 'N/A';
      $('#swapRate').textContent = 'Rate not available';
      return;
    }
    const toAmount = fromAmount * rate;
    $('#swapToAmount').value = toAmount.toFixed(6);
    $('#swapRate').textContent = `1 ${fromToken} ≈ ${rate.toFixed(4)} ${toToken}`;
  }

  ['swapFromAmount', 'swapFromToken', 'swapToToken'].forEach(id => {
    const el = $('#' + id);
    if(el) {
      el.addEventListener('input', updateSwap);
      el.addEventListener('change', updateSwap);
    }
  });
  
  $('#swapBtn').addEventListener('click', () => {
    const fromToken = $('#swapFromToken').value;
    const toToken = $('#swapToToken').value;
    const fromAmount = $('#swapFromAmount').value;
    const toAmount = $('#swapToAmount').value;
    if (parseFloat(fromAmount) > 0 && toAmount !== 'N/A') {
      logOk(`Swap simulated: ${fromAmount} ${fromToken} -> ${toAmount} ${toToken}`);
    } else {
      logWarn('Invalid swap parameters.');
    }
  });
  
  $('#aiSignalBtn').addEventListener('click', async () => {
    logInfo('Requesting AI trade signal...');
    $('#aiSignalOutput').textContent = 'Analyzing...';
    const tokenMap = {'ETH': 'Ethereum', 'BTC': 'Bitcoin', 'BITBOY': 'BITBOY Token'};
    const selectedToken = $('#swapFromToken').value;
    const tokenFullName = tokenMap[selectedToken] || selectedToken;
    
    const prompt = `Act as a crypto trade analyst. Provide a short, 2-3 sentence market analysis for ${tokenFullName} (${selectedToken}) and then on a new line, give a clear trade signal: BUY, SELL, or HOLD.`;
    const result = await aiProcess(prompt);
    $('#aiSignalOutput').textContent = result;
    logOk('AI trade signal received.');
  });
  
  // Initial call to set swap values
  updateSwap();
}

setupUI();
</script>
</body>
</html>
