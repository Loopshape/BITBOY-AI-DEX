#!/usr/bin/env bash
# ~/bin/ai - AI DevOps Platform with tools
set -euo pipefail

AI_HOME="${AI_HOME:-$HOME/.ai_builder}"
PROJECTS_DIR="$AI_HOME/projects"
MEMORY_DB="$AI_HOME/memory.db"
HASH_INDEX="$AI_HOME/hash_index.json"
POOL_INDEX="$AI_HOME/_pool_index.json"
mkdir -p "$PROJECTS_DIR"

# --- Defaults ---
DEFAULT_CONFIG='{
  "model": "gpt-4",
  "temperature": 0.7,
  "top_p": 0.9,
  "seed": null,
  "max_tokens": 4000,
  "api_port": 8080
}'
CONFIG_FILE="$AI_HOME/config.json"
[[ -f "$CONFIG_FILE" ]] || echo "$DEFAULT_CONFIG" > "$CONFIG_FILE"

# --- Initialize memory DB ---
if [[ ! -f "$MEMORY_DB" ]]; then
    sqlite3 "$MEMORY_DB" "
    CREATE TABLE memories (
      id INTEGER PRIMARY KEY,
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
      prompt TEXT,
      response TEXT,
      context TEXT,
      hash TEXT
    );
    CREATE INDEX idx_timestamp ON memories(timestamp);
    CREATE INDEX idx_hash ON memories(hash);
    "
fi

sqlite3_escape() { echo "$1" | sed "s/'/''/g"; }

# --- Memory management ---
add_to_memory() {
    local prompt="$1" response="$2" context="${3:-}" hash="${4:-}"
    sqlite3 "$MEMORY_DB" "INSERT INTO memories (prompt,response,context,hash) VALUES ('$(sqlite3_escape "$prompt")','$(sqlite3_escape "$response")','$(sqlite3_escape "$context")','$hash');"
}

search_memory() {
    local query="$1" limit="${2:-10}"
    sqlite3 -header -column "$MEMORY_DB" "SELECT timestamp,prompt,response,context FROM memories WHERE prompt LIKE '%$(sqlite3_escape "$query")%' OR response LIKE '%$(sqlite3_escape "$query")%' ORDER BY timestamp DESC LIMIT $limit"
}

clear_memory() {
    read -p "Are you sure you want to clear all memory? (y/n): " confirm
    [[ "$confirm" == "y" ]] && sqlite3 "$MEMORY_DB" "DELETE FROM memories" && echo "Memory cleared." || echo "Cancelled."
}

# --- Hashing ---
hash_prompt() { echo -n "$1" | sha256sum | awk '{print $1}'; }

gen_task_id() { echo -n "$1$(date +%s%N)" | sha256sum | cut -c1-12; }

# --- Tools ---
tool_write_file() {
    local file="$1" content="$2"
    mkdir -p "$(dirname "$file")"
    echo "$content" > "$file"
    echo "WRITE_FILE: $file written."
}

tool_run_command() {
    local cmd="$1"
    eval "$cmd"
    echo "RUN_COMMAND: executed $cmd"
}

tool_delete_file() {
    local file="$1"
    [[ -f "$file" ]] && rm "$file" && echo "DELETE_FILE: $file deleted"
}

tool_web_search() {
    local query="$*"
    echo "WEB_SEARCH: would search for: $query"
}

tool_download_file() {
    local url="$1" output="${2:-$(basename "$url")}"
    curl -s -o "$output" "$url" && echo "DOWNLOAD_FILE: $url -> $output"
}

tool_make_web_request() {
    local url="$1"
    curl -s -I "$url"
}

tool_check_port() {
    local port="$1"
    nc -z localhost "$port" >/dev/null && echo "Port $port is open" || echo "Port $port is closed"
}

execute_tools() {
    local response="$1"
    local tool_cmds
    tool_cmds=$(echo "$response" | grep -o '\[TOOL: [^]]*\]' | sed 's/\[TOOL: //;s/\]//')
    [[ -z "$tool_cmds" ]] && return

    while IFS= read -r cmd; do
        local tool_name=$(echo "$cmd" | cut -d' ' -f1)
        local args=$(echo "$cmd" | cut -d' ' -f2-)
        case "$tool_name" in
            write_file) tool_write_file $args ;;
            run_command) tool_run_command "$args" ;;
            delete_file) tool_delete_file "$args" ;;
            web_search) tool_web_search "$args" ;;
            download_file) tool_download_file $args ;;
            make_web_request) tool_make_web_request "$args" ;;
            check_port) tool_check_port "$args" ;;
            *) echo "Unknown tool: $tool_name" ;;
        esac
    done <<< "$tool_cmds"
}

# --- Model execution ---
run_model() {
    local prompt="$1"
    echo "ðŸ¤” AI thinking about: $prompt"
    sleep 1
    local response="Simulated AI response for: $prompt"
    add_to_memory "$prompt" "$response" "" "$(hash_prompt "$prompt")"
    echo "$response"
}

# --- Agent entry point ---
main() {
    [[ $# -eq 0 ]] && { echo "Usage: ai \"<prompt>\""; exit 0; }

    local prompt="$*"
    local taskId=$(gen_task_id "$prompt")
    local taskDir="$PROJECTS_DIR/$taskId"
    mkdir -p "$taskDir"
    local event_file="$taskDir/events.jsonl"

    echo "{\"worker\":\"System\",\"msg\":\"Task started\",\"taskId\":\"$taskId\",\"timestamp\":\"$(date -Iseconds)\"}" >> "$event_file"

    run_model "$prompt" | while IFS= read -r line; do
        echo "{\"worker\":\"Agent\",\"msg\":$(printf '%s' "$line" | jq -Rsa .),\"timestamp\":\"$(date -Iseconds)\"}" >> "$event_file"
    done

    execute_tools "Simulated AI response for: $prompt"

    echo "{\"worker\":\"System\",\"msg\":\"Task finished\",\"taskId\":\"$taskId\",\"timestamp\":\"$(date -Iseconds)\"}" >> "$event_file"
    echo "Task $taskId finished. Events in $event_file"
}

main "$@"
